<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Electrostatics Lab — Interactive E, V, F, U</title>
  <link rel="stylesheet" href="https://learnhw.web.app/admin" />
  <style>
    :root {
      --bg: #f8fafc;
      --surface: #ffffff;
      --border: #e5e7eb;
      --text: #0f172a;
      --muted: #64748b;
      --primary: #2563eb; /* primary accent */
      --primary-contrast: #ffffff;
      --danger: #ef4444;
      --success: #16a34a;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      color: var(--text);
      background: var(--bg);
      display: grid;
      grid-template-rows: auto 1fr auto;
      overflow: hidden;
    }

    header, footer {
      padding: 12px 20px;
      background: var(--surface);
      border-bottom: 1px solid var(--border);
    }
    footer { border-top: 1px solid var(--border); border-bottom: none; font-size: 12px; color: var(--muted); }

    header h1 { margin: 0; font-size: 20px; letter-spacing: .2px; }
    .sub { font-size: 13px; color: var(--muted); }

    .wrap {
      display: grid;
      grid-template-columns: 310px 1fr 320px;
      gap: 16px;
      padding: 16px;
      height: 100%;
      min-height: 0;
    }

    @media (max-width: 1100px) {
      .wrap { grid-template-columns: 1fr; overflow: auto; }
      body { overflow: auto; }
      canvas { height: 60vh; }
    }

    .panel {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 14px;
      box-shadow: 0 1px 2px rgba(0,0,0,.04);
      display: grid;
      gap: 12px;
      align-content: start;
    }

    .row { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 8px; }
    .row .note { font-size: 12px; color: var(--muted); }

    .group { display: grid; gap: 8px; }
    .group h3 { margin: 6px 0; font-size: 13px; color: var(--muted); letter-spacing: .2px; text-transform: uppercase; }

    .btn {
      appearance: none;
      border: 1px solid var(--border);
      background: var(--surface);
      color: var(--text);
      border-radius: 8px;
      padding: 8px 12px;
      font-weight: 600;
      cursor: pointer;
      transition: background .15s ease, color .15s ease, border-color .15s ease, transform .06s ease;
      font-size: 13px;
    }
    .btn:hover { transform: translateY(-1px); background: #f1f5f9; }
    .btn:disabled { opacity: .6; cursor: not-allowed; }
    .btn.primary { background: var(--primary); color: var(--primary-contrast); border-color: var(--primary); }
    .btn.primary:hover { filter: brightness(0.95); }
    .btn.danger { background: #fee2e2; color: #991b1b; border-color: #fecaca; }
    .btn.ok { background: #dcfce7; color: #065f46; border-color: #bbf7d0; }

    .toggle { display: inline-flex; align-items: center; gap: 8px; font-size: 13px; color: var(--text); }

    input[type="number"], select, input[type="range"] {
      background: var(--surface);
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 8px;
      padding: 6px 8px;
      outline: none;
    }

    .canvas-wrap {
      position: relative;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
    }
    canvas { display: block; width: 100%; height: 100%; background: #ffffff; }

    .legend { display: grid; gap: 6px; font-size: 12px; color: var(--muted); }
    .kbd { padding: 2px 6px; border-radius: 6px; border: 1px solid var(--border); background: #f1f5f9; color: #0f172a; }

    .stat { display: grid; grid-template-columns: 1fr auto; gap: 6px; font-size: 13px; }
    .mono { font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }

    a { color: var(--primary); text-decoration: none; }

    /* Help modal */
    .modal-backdrop { position: fixed; inset: 0; background: rgba(15,23,42,.45); display: none; align-items: center; justify-content: center; z-index: 50; }
    .modal { width: min(680px, 92vw); background: var(--surface); border: 1px solid var(--border); border-radius: 12px; padding: 16px; box-shadow: 0 20px 60px rgba(0,0,0,.15); }
    .modal h2 { margin: 0 0 6px; font-size: 18px; color: var(--text); }
    .modal .p { color: var(--muted); font-size: 14px; line-height: 1.5; }
    .modal .actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 12px; }
    .hidden { display: none !important; }
  </style>
</head>
<body>
  <header>
    <div style="display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;">
      <div>
        <h1>⚡ Electrostatics Lab — Interactive Visualizer</h1>
        <div class="sub">Explore electric field E, potential V, force F, and potential energy U with draggable point charges.</div>
      </div>
      <div style="display:flex; align-items:center; gap:8px;">
        <label class="toggle" title="Simplify the interface and enable helpful defaults">
          <input type="checkbox" id="beginnerToggle" /> Beginner Mode
        </label>
        <button id="helpBtn" class="btn" title="Open quick tour and explanations">Help</button>
      </div>
    </div>
  </header>

  <main class="wrap">
    <!-- Left Controls -->
    <aside class="panel">
      <div class="group">
        <h3>Charges</h3>
        <div class="row">
          <button id="addPos" class="btn ok" title="Place a +1 microcoulomb charge near the center">+ Add +1 µC</button>
          <div class="note">Click to add a positive charge</div>
        </div>
        <div class="row">
          <button id="addNeg" class="btn danger" title="Place a −1 microcoulomb charge near the center">+ Add −1 µC</button>
          <div class="note">Click to add a negative charge</div>
        </div>
        <div class="row">
          <button id="clear" class="btn danger" title="Remove all charges from the scene">Clear All</button>
          <div class="note">Remove all charges</div>
        </div>
      </div>

      <div class="group">
        <h3>Presets</h3>
        <div class="row"><button id="dipole" class="btn" title="Place one + charge and one − charge">Dipole</button><div class="note">+q and −q</div></div>
        <div class="row"><button id="quadrupole" class="btn" title="Place four charges in a square pattern">Quadrupole</button><div class="note">+ − − +</div></div>
        <div class="row"><button id="line3" class="btn" title="Place three + charges in a line">Line of 3</button><div class="note">+ + +</div></div>
      </div>

      <div class="group">
        <h3>Quick Start</h3>
        <div class="note">New here? Try this:</div>
        <ol class="note" style="margin:0 0 0 18px; display:grid; gap:4px;">
          <li>Click Dipole. Observe field arrows from + to −.</li>
          <li>Toggle <strong>Potential heatmap</strong> to see high/low V regions.</li>
          <li>Drag the + charge and watch E, V, F, U update at the cursor.</li>
        </ol>
        <div class="row">
          <button id="guideBtn" class="btn" title="Run a guided setup for beginners">Start Guided Demo</button>
          <div class="note">Sets helpful defaults</div>
        </div>
      </div>

      <div class="group">
        <h3>Display</h3>
        <label class="toggle"><input type="checkbox" id="showVectors" checked /> Field vectors E</label>
        <label class="toggle"><input type="checkbox" id="showHeat" checked /> Potential heatmap V</label>
        <label class="toggle"><input type="checkbox" id="showLines" /> Field lines</label>
        <div class="row">
          <label>Vector density</label>
          <input type="range" id="vecDensity" min="20" max="80" value="45" />
        </div>
        <div class="row">
          <label>Arrow scale</label>
          <input type="range" id="arrowScale" min="0.4" max="2.0" step="0.1" value="1.0" />
        </div>
        <div class="row">
          <label>Display range (±V)</label>
          <input type="number" id="displayRangeV" min="2" step="2" value="40" style="width:90px;" />
        </div>
      </div>

      <div class="legend">
        <div>Drag charges with the mouse. Hold <span class="kbd">Shift</span> while dragging to duplicate.</div>
        <div>Click empty space to place a selected charge.</div>
      </div>
    </aside>

    <!-- Canvas -->
    <section class="canvas-wrap">
      <canvas id="canvas" width="1100" height="720" aria-label="Electrostatics simulation"></canvas>
    </section>

    <!-- Right Info -->
    <aside class="panel">
      <div class="group">
        <h3>Probe (at cursor)</h3>
        <div class="stat"><div>E magnitude</div><div class="mono" id="E_mag">—</div></div>
        <div class="stat"><div>E direction</div><div class="mono" id="E_dir">—</div></div>
        <div class="stat"><div>Potential V</div><div class="mono" id="V">—</div></div>
        <div class="stat"><div>Force on 1 nC</div><div class="mono" id="F">—</div></div>
        <div class="stat"><div>Potential energy (1 nC)</div><div class="mono" id="U">—</div></div>
      </div>

      <div class="group">
        <h3>Selected charge</h3>
        <div class="stat"><div>q (µC)</div><div><input id="selQ" type="number" step="0.1" value="0" style="width:90px;" /></div></div>
        <div class="stat"><div>Lock position</div><div><input id="selLock" type="checkbox" /></div></div>
        <div class="row"><button id="selDelete" class="btn danger">Delete</button><div class="note">Remove selected</div></div>
      </div>

      <div class="group">
        <h3>Equations</h3>
        <div class="note">k = 1/(4πϵ₀) ≈ 8.9875×10⁹ N·m²/C²</div>
        <div class="note">E(r) = Σ k qᵢ (r − rᵢ) / |r − rᵢ|³</div>
        <div class="note">V(r) = Σ k qᵢ / |r − rᵢ|</div>
        <div class="note">F = q E, U = q V</div>
        <div class="note">Scale: 1 px ≈ 1 cm</div>
      </div>

      <div class="group">
        <h3>Resources</h3>
        <div class="note">Try superposition: start with a dipole then add a third charge and observe changes.</div>
      </div>

      <div class="group">
        <h3>Glossary</h3>
        <div class="note"><strong>Electric field E</strong>: how a + test charge would accelerate (direction and size).</div>
        <div class="note"><strong>Electric potential V</strong>: energy per unit charge; differences in V drive charge motion.</div>
        <div class="note"><strong>Force F</strong>: push/pull on a charge; F = qE.</div>
        <div class="note"><strong>Potential energy U</strong>: stored energy for a charge at a point; U = qV.</div>
      </div>
    </aside>
  </main>

  <footer>
    © 2025 • Educational tool for Physics II — Electrostatics
  </footer>

  <!-- Help / Onboarding Modal -->
  <div id="helpModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
    <div class="modal">
      <h2 id="helpTitle">Welcome to the Electrostatics Lab</h2>
      <div class="p" id="helpBody">
        This interactive uses point charges to visualize electric field E (arrows), potential V (optional heatmap),
        field lines, and the resulting force F and potential energy U for a tiny 1 nC probe at your cursor.
        
        <div style="margin-top:10px;">
          • Start with <strong>Dipole</strong>. • Drag charges. • Toggle the <strong>Potential heatmap</strong>.
          • Hover the canvas to see E, V, F, U at the cursor.
        </div>
      </div>
      <div class="actions">
        <label class="toggle" title="Remember this preference"><input type="checkbox" id="dontShowHelp" /> Don't show again</label>
        <button id="helpClose" class="btn">Got it</button>
      </div>
    </div>
  </div>

  <script>
    // Constants and scale
    const k = 8.9875517923e9; // N m^2 / C^2
    const meterPerPixel = 0.01; // 1 px = 1 cm
    const soften = 0.01; // meters softening to avoid singularities (~1 cm)

    // State
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const charges = []; // {id,x,y,qMicroC,locked}
    let selectedId = null;

    // UI Elements
    const addPosBtn = document.getElementById('addPos');
    const addNegBtn = document.getElementById('addNeg');
    const clearBtn = document.getElementById('clear');
    const dipoleBtn = document.getElementById('dipole');
    const quadrupoleBtn = document.getElementById('quadrupole');
    const line3Btn = document.getElementById('line3');

    const showVectorsEl = document.getElementById('showVectors');
    const showHeatEl = document.getElementById('showHeat');
    const showLinesEl = document.getElementById('showLines');
    const vecDensityEl = document.getElementById('vecDensity');
    const arrowScaleEl = document.getElementById('arrowScale');
    const displayRangeEl = document.getElementById('displayRangeV');

    const E_magEl = document.getElementById('E_mag');
    const E_dirEl = document.getElementById('E_dir');
    const VEl = document.getElementById('V');
    const FEl = document.getElementById('F');
    const UEl = document.getElementById('U');

    const selQEl = document.getElementById('selQ');
    const selLockEl = document.getElementById('selLock');
    const selDeleteEl = document.getElementById('selDelete');

    // Beginner + Help
    const beginnerToggle = document.getElementById('beginnerToggle');
    const helpBtn = document.getElementById('helpBtn');
    const helpModal = document.getElementById('helpModal');
    const helpClose = document.getElementById('helpClose');
    const dontShowHelp = document.getElementById('dontShowHelp');
    const guideBtn = document.getElementById('guideBtn');

    // Helpers
    const fmt = (x, unit) => {
      if (!isFinite(x)) return '—';
      const ax = Math.abs(x);
      let v = x, p = '';
      if (ax >= 1e9) { v = x/1e9; p = 'G'; }
      else if (ax >= 1e6) { v = x/1e6; p = 'M'; }
      else if (ax >= 1e3) { v = x/1e3; p = 'k'; }
      else if (ax < 1e-9) { v = x*1e12; p = 'p'; }
      else if (ax < 1e-6) { v = x*1e9; p = 'n'; }
      else if (ax < 1e-3) { v = x*1e6; p = 'µ'; }
      else if (ax < 1) { v = x*1e3; p = 'm'; }
      return v.toFixed(3).replace(/\.0+$/,'').replace(/(\.\d*?)0+$/,'$1') + ' ' + p + unit;
    };

    function toMeters(dxPx, dyPx){
      return { dx: dxPx * meterPerPixel, dy: dyPx * meterPerPixel };
    }

    function E_and_V_at(x, y){
      // x,y in pixels canvas coordinates
      let Ex = 0, Ey = 0, V = 0;
      for (const c of charges){
        const dxPx = x - c.x;
        const dyPx = y - c.y;
        const {dx, dy} = toMeters(dxPx, dyPx);
        const r2 = dx*dx + dy*dy + soften*soften;
        const r = Math.sqrt(r2);
        const qC = c.qMicroC * 1e-6; // C
        const coeff = k * qC / (r2 * r); // k q / r^3
        Ex += coeff * dx;
        Ey += coeff * dy;
        V += k * qC / r; // k q / r
      }
      return {Ex, Ey, V};
    }

    function drawGrid(){
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,.05)';
      ctx.lineWidth = 1;
      for (let x=0; x<canvas.width; x+=40){
        ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke();
      }
      for (let y=0; y<canvas.height; y+=40){
        ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke();
      }
      ctx.restore();
    }

    function drawCharges(){
      for (const c of charges){
        const r = 14;
        // halo
        ctx.beginPath();
        const grad = ctx.createRadialGradient(c.x, c.y, 2, c.x, c.y, r*2.5);
        grad.addColorStop(0, c.qMicroC >= 0 ? 'rgba(34,211,238,.35)' : 'rgba(239,68,68,.35)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;
        ctx.arc(c.x, c.y, r*2.5, 0, Math.PI*2); ctx.fill();

        // body
        ctx.beginPath();
        ctx.fillStyle = c.qMicroC >= 0 ? '#22d3ee' : '#ef4444';
        ctx.strokeStyle = 'rgba(255,255,255,.8)';
        ctx.lineWidth = 1.5;
        ctx.arc(c.x, c.y, r, 0, Math.PI*2);
        ctx.fill(); ctx.stroke();

        // symbol
        ctx.fillStyle = '#0b1022';
        ctx.font = 'bold 14px ui-sans-serif, system-ui, -apple-system';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(c.qMicroC >= 0 ? '+' : '−', c.x, c.y);

        // selection ring
        if (c.id === selectedId){
          ctx.beginPath();
          ctx.strokeStyle = '#fff'; ctx.setLineDash([4,4]);
          ctx.arc(c.x, c.y, r+5, 0, Math.PI*2);
          ctx.stroke(); ctx.setLineDash([]);
        }
      }
    }

    function drawVector(x, y, Ex, Ey){
      const scale = parseFloat(arrowScaleEl.value);
      // draw arrow based on E
      const mag = Math.hypot(Ex, Ey);
      if (mag <= 0) return;
      const nx = Ex / mag, ny = Ey / mag;
      const len = Math.min(22, 4 + 8 * Math.log10(1 + mag*1e6)) * scale; // perceptual scaling
      const x2 = x + nx * len;
      const y2 = y + ny * len;
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(255,255,255,.85)';
      ctx.lineWidth = 1;
      ctx.moveTo(x, y); ctx.lineTo(x2, y2); ctx.stroke();
      // head
      const head = 4 * scale;
      const tx = -ny, ty = nx;
      ctx.beginPath(); ctx.moveTo(x2, y2);
      ctx.lineTo(x2 - nx*6 + tx*head, y2 - ny*6 + ty*head);
      ctx.lineTo(x2 - nx*6 - tx*head, y2 - ny*6 - ty*head);
      ctx.closePath(); ctx.fillStyle = 'rgba(255,255,255,.85)'; ctx.fill();
    }

    function drawFieldVectors(){
      const step = parseInt(vecDensityEl.value, 10);
      for (let y = step/2; y < canvas.height; y += step){
        for (let x = step/2; x < canvas.width; x += step){
          const {Ex, Ey} = E_and_V_at(x, y);
          drawVector(x, y, Ex, Ey);
        }
      }
    }

    // Heatmap (potential)
    let heatCache = null, heatDirty = true;
    function computeHeatmap(){
      const w = 220, h = Math.round(w * canvas.height / canvas.width);
      const off = document.createElement('canvas'); off.width = w; off.height = h;
      const ictx = off.getContext('2d');
      const img = ictx.createImageData(w, h);
      const Vs = new Float32Array(w*h);
      let i=0, vmin=Infinity, vmax=-Infinity;
      for (let j=0; j<h; j++){
        for (let i2=0; i2<w; i2++){
          const x = (i2 + 0.5) * canvas.width / w;
          const y = (j + 0.5) * canvas.height / h;
          const {V} = E_and_V_at(x, y);
          Vs[i] = V; vmin = Math.min(vmin, V); vmax = Math.max(vmax, V); i++;
        }
      }
      // Discrete 2 V bands, symmetric around 0 with clipping for visualization
      const a = Math.max(Math.abs(vmin), Math.abs(vmax)) || 1;
      const userRange = Math.max(2, Math.abs(parseFloat(displayRangeEl.value)||40));
      const Vclip = Math.min(a, userRange); // user-controlled ±V window
      const totalBands = Math.max(1, Math.floor((2 * Vclip) / 2)); // 2V per band
      i=0; for (let j=0; j<h; j++){
        for (let i2=0; i2<w; i2++){
          const Vraw = Vs[i++];
          const Vc = Math.max(-Vclip, Math.min(Vraw, Vclip));
          const bandIndex = Math.floor((Vc + Vclip) / 2); // 2V per band
          const tBand = totalBands > 0 ? (bandIndex / totalBands) : 0.5; // [0,1]
          const t = tBand * 2 - 1; // [-1,1]
          const {r,g,b} = divergingColormap(t);
          const k = (j*w + i2) * 4;
          img.data[k] = r; img.data[k+1] = g; img.data[k+2] = b; img.data[k+3] = 200; // slightly higher alpha for crisp bands
        }
      }
      ictx.putImageData(img, 0, 0);
      heatCache = off; heatDirty = false;
    }

    function divergingColormap(t){
      // Multi-stop gradient: purple (low) → blue → green → yellow → orange → red (high)
      const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
      t = clamp(t,-1,1);
      const stops = [
        { t:-1.0, c:{r:128,g:0  ,b:128} }, // purple
        { t:-0.6, c:{r:0  ,g:102,b:204} }, // blue
        { t:-0.2, c:{r:0  ,g:153,b:0  } }, // green
        { t: 0.2, c:{r:255,g:235,b:59 } }, // yellow
        { t: 0.6, c:{r:255,g:152,b:0  } }, // orange
        { t: 1.0, c:{r:211,g:47 ,b:47 } }  // red
      ];
      // find segment
      for (let i=0; i<stops.length-1; i++){
        const a = stops[i], b = stops[i+1];
        if (t >= a.t && t <= b.t){
          const u = (t - a.t) / (b.t - a.t);
          const lerp=(x,y,p)=>Math.round(x + (y - x) * p);
          return {
            r: lerp(a.c.r, b.c.r, u),
            g: lerp(a.c.g, b.c.g, u),
            b: lerp(a.c.b, b.c.b, u)
          };
        }
      }
      return stops[t<0?0:stops.length-1].c;
    }

    function drawHeat(){
      if (heatDirty) computeHeatmap();
      ctx.save();
      ctx.imageSmoothingEnabled = true;
      ctx.drawImage(heatCache, 0, 0, canvas.width, canvas.height);
      ctx.restore();
    }

    // Field lines via streamline integration
    function drawFieldLines(){
      const seedsPerCharge = 12;
      const maxSteps = 1500;
      const stepLen = 6; // px per step
      ctx.save();
      ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(255,255,255,.6)';
      for (const c of charges){
        const sign = Math.sign(c.qMicroC) || 1;
        const r = 16;
        for (let kSeed=0; kSeed<seedsPerCharge; kSeed++){
          const ang = (kSeed / seedsPerCharge) * Math.PI * 2;
          let x = c.x + Math.cos(ang)*r;
          let y = c.y + Math.sin(ang)*r;
          ctx.beginPath(); ctx.moveTo(x, y);
          for (let s=0; s<maxSteps; s++){
            const {Ex, Ey} = E_and_V_at(x, y);
            let mag = Math.hypot(Ex, Ey);
            if (mag < 1e-6) break;
            const nx = Ex / mag * sign; const ny = Ey / mag * sign;
            x += nx * stepLen; y += ny * stepLen;
            if (x<0||y<0||x>canvas.width||y>canvas.height) break;
            // Stop if near an opposite-sign charge
            let nearOpp = false;
            for (const c2 of charges){
              const dx = x - c2.x, dy = y - c2.y;
              if (Math.hypot(dx,dy) < 10 && Math.sign(c2.qMicroC) !== sign){ nearOpp = true; break; }
            }
            ctx.lineTo(x, y);
            if (nearOpp) break;
          }
          ctx.stroke();
        }
      }
      ctx.restore();
    }

    // Interaction
    let draggingId = null; let dragOffset = {x:0,y:0}; let isDup = false;
    function pickCharge(x, y){
      for (let i=charges.length-1; i>=0; i--){
        const c = charges[i];
        if (Math.hypot(x-c.x, y-c.y) <= 16) return c.id;
      }
      return null;
    }

    canvas.addEventListener('mousedown', (e)=>{
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvas.width/rect.width);
      const y = (e.clientY - rect.top) * (canvas.height/rect.height);
      const id = pickCharge(x, y);
      if (id !== null){
        const c = charges.find(c=>c.id===id);
        if (c && c.locked) return;
        draggingId = id; selectedId = id; isDup = e.shiftKey;
        dragOffset.x = x - c.x; dragOffset.y = y - c.y;
      } else {
        // Place a copy of selected charge at click
        const cSel = charges.find(c=>c.id===selectedId);
        if (cSel){ addCharge(x, y, cSel.qMicroC); }
      }
      syncSelectedPanel();
    });

    canvas.addEventListener('mousemove', (e)=>{
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvas.width/rect.width);
      const y = (e.clientY - rect.top) * (canvas.height/rect.height);
      // Probe values
      const {Ex, Ey, V} = E_and_V_at(x, y);
      const Emag = Math.hypot(Ex, Ey);
      const angle = Math.atan2(Ey, Ex) * 180/Math.PI;
      E_magEl.textContent = fmt(Emag, 'N/C');
      E_dirEl.textContent = isFinite(angle) ? angle.toFixed(1)+'°' : '—';
      VEl.textContent = fmt(V, 'V');
      const qProbe = 1e-9; // 1 nC
      FEl.textContent = fmt(Emag*qProbe, 'N');
      UEl.textContent = fmt(V*qProbe, 'J');

      if (draggingId !== null){
        const idx = charges.findIndex(c=>c.id===draggingId);
        if (idx>=0){
          if (isDup){ // duplicate once at drag start
            const c0 = charges[idx];
            const dup = addCharge(c0.x, c0.y, c0.qMicroC);
            draggingId = dup.id; isDup = false;
          }
          const c = charges.find(c=>c.id===draggingId);
          if (c && !c.locked){ c.x = x - dragOffset.x; c.y = y - dragOffset.y; heatDirty = true; }
        }
      }
    });

    window.addEventListener('mouseup', ()=>{ draggingId = null; });

    function addCharge(x, y, qMicroC){
      const id = Math.random().toString(36).slice(2);
      charges.push({id, x, y, qMicroC, locked:false});
      selectedId = id; heatDirty = true; return {id};
    }

    function clearCharges(){ charges.length = 0; selectedId = null; heatDirty = true; }

    function center(){ return {x: canvas.width/2, y: canvas.height/2}; }

    // Presets
    function presetDipole(){
      clearCharges(); const c = center();
      addCharge(c.x-80, c.y, +1.0); addCharge(c.x+80, c.y, -1.0);
    }
    function presetQuadrupole(){
      clearCharges(); const c = center(); const d=90;
      addCharge(c.x-d, c.y-d, +1.0); addCharge(c.x+d, c.y-d, -1.0);
      addCharge(c.x-d, c.y+d, -1.0); addCharge(c.x+d, c.y+d, +1.0);
    }
    function presetLine3(){
      clearCharges(); const c = center(); const d=90;
      addCharge(c.x-d, c.y, +1.0); addCharge(c.x, c.y, +1.0); addCharge(c.x+d, c.y, +1.0);
    }

    // Bind UI
    addPosBtn.addEventListener('click', ()=>{ const c=center(); addCharge(c.x+ (Math.random()*60-30), c.y+(Math.random()*60-30), +1.0); });
    addNegBtn.addEventListener('click', ()=>{ const c=center(); addCharge(c.x+ (Math.random()*60-30), c.y+(Math.random()*60-30), -1.0); });
    clearBtn.addEventListener('click', clearCharges);
    dipoleBtn.addEventListener('click', presetDipole);
    quadrupoleBtn.addEventListener('click', presetQuadrupole);
    line3Btn.addEventListener('click', presetLine3);
    showHeatEl.addEventListener('change', ()=>{ heatDirty = true; });
    vecDensityEl.addEventListener('input', ()=>{});
    arrowScaleEl.addEventListener('input', ()=>{});
    displayRangeEl.addEventListener('input', ()=>{ heatDirty = true; });

    function syncSelectedPanel(){
      const c = charges.find(c=>c.id===selectedId);
      if (!c){ selQEl.value = 0; selLockEl.checked = false; return; }
      selQEl.value = c.qMicroC.toString(); selLockEl.checked = !!c.locked;
    }
    selQEl.addEventListener('change', ()=>{ const c = charges.find(c=>c.id===selectedId); if (c){ c.qMicroC = parseFloat(selQEl.value)||0; heatDirty = true; } });
    selLockEl.addEventListener('change', ()=>{ const c = charges.find(c=>c.id===selectedId); if (c){ c.locked = selLockEl.checked; } });
    selDeleteEl.addEventListener('click', ()=>{ const i = charges.findIndex(c=>c.id===selectedId); if (i>=0){ charges.splice(i,1); selectedId=null; heatDirty = true; syncSelectedPanel(); } });

    // Render loop
    function render(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if (showHeatEl.checked){ drawHeat(); }
      drawGrid();
      if (showVectorsEl.checked){ drawFieldVectors(); }
      if (showLinesEl.checked){ drawFieldLines(); }
      drawCharges();
      requestAnimationFrame(render);
    }

    // Init
    presetDipole();
    syncSelectedPanel();
    render();

    // Beginner Mode helpers
    function setBeginnerMode(on){
      beginnerToggle.checked = !!on;
      // Defaults for beginners: vectors on, heatmap off, lines off, lower density, bigger arrows
      showVectorsEl.checked = true;
      showHeatEl.checked = false;
      showLinesEl.checked = false;
      vecDensityEl.value = on ? 60 : 45;
      arrowScaleEl.value = on ? 1.2 : 1.0;
      localStorage.setItem('electro_beginner_mode', on ? '1' : '0');
      heatDirty = true;
    }

    beginnerToggle.addEventListener('change', ()=> setBeginnerMode(beginnerToggle.checked));

    // Help modal
    function openHelp(){ helpModal.style.display = 'flex'; }
    function closeHelp(){ helpModal.style.display = 'none'; if (dontShowHelp.checked){ localStorage.setItem('electro_help_seen','1'); } }
    helpBtn.addEventListener('click', openHelp);
    helpClose.addEventListener('click', closeHelp);
    helpModal.addEventListener('click', (e)=>{ if (e.target === helpModal) closeHelp(); });

    // Guided Demo
    guideBtn.addEventListener('click', ()=>{
      presetDipole();
      setBeginnerMode(true);
      openHelp();
    });

    // First-visit behavior
    const seen = localStorage.getItem('electro_help_seen') === '1';
    const savedBeg = localStorage.getItem('electro_beginner_mode') === '1';
    setBeginnerMode(savedBeg || !seen);
    if (!seen) { openHelp(); }
  </script>
</body>
</html>

