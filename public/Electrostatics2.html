<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Electrostatics 2 — Equipotentials & Electron Flow</title>
  <link rel="stylesheet" href="https://learnhw.web.app/admin" />
  <style>
    :root {
      --bg: #f8fafc;
      --surface: #ffffff;
      --border: #e5e7eb;
      --text: #0f172a;
      --muted: #64748b;
      --primary: #2563eb;
      --primary-contrast: #ffffff;
      --danger: #ef4444;
      --success: #16a34a;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; color: var(--text);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg);
      display: grid; grid-template-rows: auto 1fr auto; overflow: hidden;
    }

    header, footer {
      padding: 12px 20px; background: var(--surface); border-bottom: 1px solid var(--border);
    }
    footer { border-top: 1px solid var(--border); border-bottom: none; font-size: 12px; color: var(--muted); }
    header h1 { margin: 0; font-size: 20px; }
    .sub { font-size: 13px; color: var(--muted); }

    .wrap { display: grid; grid-template-columns: 300px 1fr 300px; gap: 16px; padding: 16px; height: 100%; min-height: 0; }
    @media (max-width: 1100px){ .wrap { grid-template-columns: 1fr; overflow: auto; } body { overflow: auto; } canvas { height: 60vh; } }

    .panel { background: var(--surface); border: 1px solid var(--border); border-radius: 12px; padding: 14px; box-shadow: 0 1px 2px rgba(0,0,0,.04); display: grid; gap: 12px; align-content: start; }
    .group { display: grid; gap: 8px; }
    .group h3 { margin: 2px 0 4px; font-size: 13px; color: var(--muted); text-transform: uppercase; letter-spacing: .2px; }
    .row { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 8px; }
    .note { font-size: 12px; color: var(--muted); }

    .btn { appearance: none; border: 1px solid var(--border); background: var(--surface); color: var(--text); border-radius: 8px; padding: 8px 12px; font-weight: 600; font-size: 13px; cursor: pointer; transition: background .15s ease, transform .06s ease; }
    .btn:hover { transform: translateY(-1px); background: #f1f5f9; }
    .btn.primary { background: var(--primary); color: var(--primary-contrast); border-color: var(--primary); }
    .btn.primary:hover { filter: brightness(0.95); }
    .btn.danger { background: #fee2e2; color: #991b1b; border-color: #fecaca; }
    .btn.ok { background: #dcfce7; color: #065f46; border-color: #bbf7d0; }

    input[type="number"], input[type="range"] { background: var(--surface); border: 1px solid var(--border); color: var(--text); border-radius: 8px; padding: 6px 8px; outline: none; }
    .toggle { display: inline-flex; align-items: center; gap: 8px; font-size: 13px; }

    .canvas-wrap { position: relative; background: var(--surface); border: 1px solid var(--border); border-radius: 12px; overflow: hidden; }
    canvas { display: block; width: 100%; height: 100%; background: #ffffff; }

    .legend { display: grid; gap: 6px; font-size: 12px; color: var(--muted); }
    .kbd { padding: 2px 6px; border-radius: 6px; border: 1px solid var(--border); background: #f1f5f9; color: #0f172a; }

    .mono { font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    a { color: var(--primary); text-decoration: none; }
  </style>
</head>
<body>
  <header>
    <div style="display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;">
      <div>
        <h1>⚡ Electrostatics 2 — Equipotentials & Electron Flow</h1>
        <div class="sub">Hot→cool gradient for potential. Simulate electron flow along field lines.</div>
      </div>
      <div style="display:flex; gap:8px; align-items:center;">
        <button id="simulate" class="btn primary" title="Toggle electron flow and field lines">Simulate Flow</button>
        <button id="resetSim" class="btn" title="Stop and clear electrons">Reset</button>
      </div>
    </div>
  </header>

  <main class="wrap">
    <aside class="panel">
      <div class="group">
        <h3>Charges</h3>
        <div class="row"><button id="addPos" class="btn ok" title="Add +1 µC near center">+ Add +1 µC</button><div class="note">Positive charge</div></div>
        <div class="row"><button id="addNeg" class="btn danger" title="Add −1 µC near center">+ Add −1 µC</button><div class="note">Negative charge</div></div>
        <div class="row"><button id="clear" class="btn danger" title="Remove all charges">Clear All</button><div class="note">Reset scene</div></div>
      </div>

      <div class="group">
        <h3>Presets</h3>
        <div class="row"><button id="dipole" class="btn">Dipole</button><div class="note">+q and −q</div></div>
      </div>

      <div class="group">
        <h3>Display</h3>
        <label class="toggle"><input type="checkbox" id="showHeat" checked /> Show potential heatmap (hot→cool)</label>
        <div class="row"><label>Heatmap detail</label><input id="heatRes" type="range" min="120" max="480" step="20" value="260" /></div>
        <label class="toggle"><input type="checkbox" id="showVectors" /> Show field vectors E</label>
        <div class="row"><label>Display range (±V)</label><input id="displayRangeV2" type="number" min="2" step="2" value="40" style="width:90px;" /></div>
      </div>

      <div class="group">
        <h3>Interaction</h3>
        <div class="legend">
          <div>Drag charges. Hold <span class="kbd">Shift</span> while dragging to duplicate.</div>
          <div>Electrons flow opposite to E (since q<0).</div>
        </div>
      </div>
    </aside>

    <section class="canvas-wrap">
      <canvas id="canvas" width="1100" height="720" aria-label="Electrostatics simulation"></canvas>
    </section>

    <aside class="panel">
      <div class="group">
        <h3>Probe (cursor)</h3>
        <div class="row"><div>E |N/C|</div><div class="mono" id="E_mag">—</div></div>
        <div class="row"><div>V (potential)</div><div class="mono" id="V">—</div></div>
      </div>
      <div class="group">
        <h3>About</h3>
        <div class="note">Heatmap shows V: hot (red) for higher V, cool (blue) for lower V. Field lines and electrons appear when you press <em>Simulate Flow</em>.</div>
        <div class="note">Style guided by <a href="https://learnhw.web.app/admin" target="_blank" rel="noopener">admin design</a>.</div>
      </div>
    </aside>
  </main>

  <footer>© 2025 • Electrostatics visualization — equipotentials and electron flow</footer>

  <script>
    // Physics constants
    const k = 8.9875517923e9; // N m^2 / C^2
    const meterPerPixel = 0.01; // 1 px = 1 cm
    const soften = 0.01; // m — avoid singularities

    // Elements
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const addPosBtn = document.getElementById('addPos');
    const addNegBtn = document.getElementById('addNeg');
    const clearBtn = document.getElementById('clear');
    const dipoleBtn = document.getElementById('dipole');
    const simulateBtn = document.getElementById('simulate');
    const resetSimBtn = document.getElementById('resetSim');
    const showHeatEl = document.getElementById('showHeat');
    const heatResEl = document.getElementById('heatRes');
    const showVectorsEl = document.getElementById('showVectors');
    const displayRangeEl2 = document.getElementById('displayRangeV2');
    const E_magEl = document.getElementById('E_mag');
    const VEl = document.getElementById('V');

    // State
    const charges = []; // {id,x,y,qMicroC,locked}
    let selectedId = null;
    let draggingId = null; let dragOffset = {x:0,y:0}; let dupOnDrag = false;
    let heatCache = null; let heatDirty = true;
    let simRunning = false;
    let electrons = []; // {x,y,life}

    // Helpers
    function toMeters(dxPx, dyPx){ return { dx: dxPx * meterPerPixel, dy: dyPx * meterPerPixel }; }
    function E_and_V_at(x, y){
      let Ex = 0, Ey = 0, V = 0;
      for (const c of charges){
        const dxPx = x - c.x, dyPx = y - c.y;
        const {dx, dy} = toMeters(dxPx, dyPx);
        const r2 = dx*dx + dy*dy + soften*soften; const r = Math.sqrt(r2);
        const qC = c.qMicroC * 1e-6;
        const coeff = k * qC / (r2 * r);
        Ex += coeff * dx; Ey += coeff * dy; V += k * qC / r;
      }
      return {Ex, Ey, V};
    }
    function fmt(x, unit){ if(!isFinite(x)) return '—'; const ax=Math.abs(x); let v=x, p=''; if(ax>=1e6){v=x/1e6;p='M';} else if(ax>=1e3){v=x/1e3;p='k';} else if(ax<1e-6){v=x*1e9;p='n';} else if(ax<1e-3){v=x*1e6;p='µ';} else if(ax<1){v=x*1e3;p='m';} return v.toFixed(3).replace(/\.0+$/,'').replace(/(\.\d*?)0+$/,'$1')+ ' ' + p + unit; }

    // Heatmap: purple (low) → blue → green → yellow → orange → red (high)
    function colorHotCool(t){ // t in [-1,1]
      const clamp=(v,min,max)=>Math.max(min,Math.min(max,v)); t=clamp(t,-1,1);
      const stops = [
        { t:-1.0, c:[128,0  ,128, 185] }, // purple
        { t:-0.6, c:[0  ,102,204, 185] }, // blue
        { t:-0.2, c:[0  ,153,0  , 185] }, // green
        { t: 0.2, c:[255,235,59 , 185] }, // yellow
        { t: 0.6, c:[255,152,0  , 185] }, // orange
        { t: 1.0, c:[211,47 ,47 , 185] }  // red
      ];
      for(let i=0;i<stops.length-1;i++){
        const a=stops[i], b=stops[i+1];
        if(t>=a.t && t<=b.t){
          const u=(t-a.t)/(b.t-a.t);
          const lerp=(x,y,p)=>Math.round(x+(y-x)*p);
          return [ lerp(a.c[0],b.c[0],u), lerp(a.c[1],b.c[1],u), lerp(a.c[2],b.c[2],u), lerp(a.c[3],b.c[3],u) ];
        }
      }
      return stops[t<0?0:stops.length-1].c;
    }
    function computeHeatmap(){
      const w = parseInt(heatResEl.value,10); const h = Math.round(w * canvas.height / canvas.width);
      const off = document.createElement('canvas'); off.width = w; off.height = h; const ictx = off.getContext('2d');
      const img = ictx.createImageData(w,h); const Vs = new Float32Array(w*h);
      let vmin=Infinity, vmax=-Infinity, i=0;
      for(let j=0;j<h;j++){
        for(let i2=0;i2<w;i2++){
          const x = (i2+0.5) * canvas.width / w; const y = (j+0.5) * canvas.height / h;
          const {V} = E_and_V_at(x,y); Vs[i]=V; if(V<vmin) vmin=V; if(V>vmax) vmax=V; i++;
        }
      }
      const a = Math.max(Math.abs(vmin), Math.abs(vmax)) || 1;
      const userRange = Math.max(2, Math.abs(parseFloat(displayRangeEl2.value)||40));
      const Vclip = Math.min(a, userRange);
      const totalBands = Math.max(1, Math.floor((2 * Vclip) / 2)); // 2V per band
      i=0; for(let j=0;j<h;j++){
        for(let i2=0;i2<w;i2++){
          const Vraw = Vs[i++];
          const Vc = Math.max(-Vclip, Math.min(Vraw, Vclip));
          const bandIndex = Math.floor((Vc + Vclip) / 2);
          const tBand = totalBands > 0 ? (bandIndex / totalBands) : 0.5;
          const t = tBand * 2 - 1;
          const [r,g,b,a8] = colorHotCool(t); const k = (j*w + i2) * 4;
          img.data[k]=r; img.data[k+1]=g; img.data[k+2]=b; img.data[k+3]=a8;
        }
      }
      ictx.putImageData(img,0,0); heatCache = off; heatDirty=false;
    }

    // Field vectors (optional)
    function drawVectors(){
      const step = 50; // fixed density for clarity
      ctx.save(); ctx.strokeStyle = 'rgba(15,23,42,.7)'; ctx.lineWidth = 1;
      for(let y=step/2; y<canvas.height; y+=step){
        for(let x=step/2; x<canvas.width; x+=step){
          const {Ex,Ey} = E_and_V_at(x,y); const m = Math.hypot(Ex,Ey); if(m<=0) continue;
          const nx=Ex/m, ny=Ey/m; const len = Math.min(26, 6 + 8*Math.log10(1+m*1e6));
          const x2 = x + nx*len; const y2 = y + ny*len;
          ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x2,y2); ctx.stroke();
          const tx=-ny, ty=nx; ctx.beginPath(); ctx.moveTo(x2,y2);
          ctx.lineTo(x2 - nx*6 + tx*3, y2 - ny*6 + ty*3);
          ctx.lineTo(x2 - nx*6 - tx*3, y2 - ny*6 - ty*3);
          ctx.closePath(); ctx.fillStyle='rgba(15,23,42,.7)'; ctx.fill();
        }
      }
      ctx.restore();
    }

    // Field lines (shown during simulation)
    function drawFieldLines(){
      const seedsPer = 10, stepLen=6, maxSteps=1200;
      ctx.save(); ctx.strokeStyle='rgba(15,23,42,.35)'; ctx.lineWidth=1;
      for(const c of charges){
        const r0=16; for(let k=0;k<seedsPer;k++){
          const ang = (k/seedsPer)*Math.PI*2; let x=c.x+Math.cos(ang)*r0; let y=c.y+Math.sin(ang)*r0;
          ctx.beginPath(); ctx.moveTo(x,y);
          for(let s=0;s<maxSteps;s++){
            const {Ex,Ey}=E_and_V_at(x,y); const m=Math.hypot(Ex,Ey); if(m<1e-7) break;
            const nx=Ex/m, ny=Ey/m; x+=nx*stepLen; y+=ny*stepLen; ctx.lineTo(x,y);
            if(x<0||y<0||x>canvas.width||y>canvas.height) break;
          }
          ctx.stroke();
        }
      }
      ctx.restore();
    }

    // Electron flow (particles move opposite to E)
    function seedElectrons(count=280){
      electrons.length=0; for(let i=0;i<count;i++){
        electrons.push({ x: Math.random()*canvas.width, y: Math.random()*canvas.height, life: Math.random()*800+400 });
      }
    }
    function stepElectrons(){
      const speedBase = 0.5; // slower base speed for clear observation
      for(const e of electrons){
        const {Ex,Ey} = E_and_V_at(e.x,e.y); const m = Math.hypot(Ex,Ey);
        if(m>0){ const nx=Ex/m, ny=Ey/m; // E direction
          // move opposite to E (electron, q<0), speed scales with field (log for stability) but capped
          const v = Math.min(1.2, speedBase * (1 + Math.log10(1+m*1e6)));
          e.x -= nx * v; e.y -= ny * v;
        }
        e.life -= 1; if(e.life<=0 || e.x<0||e.y<0||e.x>canvas.width||e.y>canvas.height){
          e.x = Math.random()*canvas.width; e.y = Math.random()*canvas.height; e.life = Math.random()*800+400;
        }
      }
    }
    function drawElectrons(){
      ctx.save();
      for(const e of electrons){
        // white circle with black border and 'e' inside
        ctx.beginPath();
        ctx.arc(e.x, e.y, 4, 0, Math.PI*2);
        ctx.fillStyle = '#ffffff';
        ctx.fill();
        ctx.lineWidth = 1.2;
        ctx.strokeStyle = '#000000';
        ctx.stroke();
        ctx.fillStyle = '#000000';
        ctx.font = 'bold 7px system-ui, -apple-system, Segoe UI';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText('e', e.x, e.y+0.3);
      }
      ctx.restore();
    }

    // Charges drawing & interaction
    function drawCharges(){
      for(const c of charges){
        const r=12; ctx.beginPath(); ctx.fillStyle = c.qMicroC>=0 ? '#ef4444' : '#3b82f6';
        ctx.strokeStyle='#0f172a'; ctx.lineWidth=1; ctx.arc(c.x,c.y,r,0,Math.PI*2); ctx.fill(); ctx.stroke();
        ctx.fillStyle='#ffffff'; ctx.font='bold 12px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(c.qMicroC>=0?'+':'−', c.x, c.y);
      }
    }
    function pickCharge(x,y){ for(let i=charges.length-1;i>=0;i--){ const c=charges[i]; if(Math.hypot(x-c.x,y-c.y)<=14) return c.id; } return null; }
    canvas.addEventListener('mousedown',(e)=>{
      const r=canvas.getBoundingClientRect(); const x=(e.clientX-r.left)*(canvas.width/r.width); const y=(e.clientY-r.top)*(canvas.height/r.height);
      const id=pickCharge(x,y); if(id){ const c=charges.find(c=>c.id===id); draggingId=id; selectedId=id; dupOnDrag=e.shiftKey; dragOffset.x=x-c.x; dragOffset.y=y-c.y; }
    });
    canvas.addEventListener('mousemove',(e)=>{
      const r=canvas.getBoundingClientRect(); const x=(e.clientX-r.left)*(canvas.width/r.width); const y=(e.clientY-r.top)*(canvas.height/r.height);
      const {Ex,Ey,V}=E_and_V_at(x,y); E_magEl.textContent=fmt(Math.hypot(Ex,Ey),'N/C'); VEl.textContent=fmt(V,'V');
      if(draggingId){ const i=charges.findIndex(c=>c.id===draggingId); if(i>=0){ if(dupOnDrag){ const c0=charges[i]; const dup=addCharge(c0.x,c0.y,c0.qMicroC); draggingId=dup.id; dupOnDrag=false; } const c=charges.find(c=>c.id===draggingId); c.x=x-dragOffset.x; c.y=y-dragOffset.y; heatDirty=true; } }
    });
    window.addEventListener('mouseup',()=>{ draggingId=null; });

    function addCharge(x,y,qMicroC){ const id=Math.random().toString(36).slice(2); charges.push({id,x,y,qMicroC,locked:false}); selectedId=id; heatDirty=true; return {id}; }
    function clearCharges(){ charges.length=0; selectedId=null; heatDirty=true; }
    function center(){ return {x: canvas.width/2, y: canvas.height/2}; }
    function presetDipole(){ clearCharges(); const c=center(); addCharge(c.x-90,c.y,+1.0); addCharge(c.x+90,c.y,-1.0); }

    // UI bindings
    addPosBtn.addEventListener('click',()=>{ const c=center(); addCharge(c.x+(Math.random()*60-30), c.y+(Math.random()*60-30), +1.0); });
    addNegBtn.addEventListener('click',()=>{ const c=center(); addCharge(c.x+(Math.random()*60-30), c.y+(Math.random()*60-30), -1.0); });
    clearBtn.addEventListener('click',()=>{ clearCharges(); heatDirty=true; });
    dipoleBtn.addEventListener('click',presetDipole);
    showHeatEl.addEventListener('change',()=>{ heatDirty=true; });
    heatResEl.addEventListener('input',()=>{ heatDirty=true; });
    showVectorsEl.addEventListener('change',()=>{});
    displayRangeEl2.addEventListener('input',()=>{ heatDirty=true; });
    simulateBtn.addEventListener('click',()=>{ simRunning=!simRunning; simulateBtn.textContent = simRunning? 'Stop' : 'Simulate Flow'; if(simRunning){ if(electrons.length===0) seedElectrons(); } });
    resetSimBtn.addEventListener('click',()=>{ simRunning=false; simulateBtn.textContent='Simulate Flow'; electrons.length=0; });

    // Render
    function render(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if(showHeatEl.checked){ if(heatDirty) computeHeatmap(); ctx.drawImage(heatCache,0,0,canvas.width,canvas.height); }
      if(simRunning){ drawFieldLines(); stepElectrons(); drawElectrons(); }
      if(showVectorsEl.checked){ drawVectors(); }
      drawCharges();
      requestAnimationFrame(render);
    }

    // Init
    presetDipole();
    render();
  </script>
</body>
</html>

