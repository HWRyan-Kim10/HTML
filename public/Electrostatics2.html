<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Electrostatics 2 — Equipotentials & Electron Flow</title>
  <link rel="stylesheet" href="https://learnhw.web.app/admin" />
  <style>
    :root {
      --bg: #f8fafc;
      --surface: #ffffff;
      --border: #e5e7eb;
      --text: #0f172a;
      --muted: #64748b;
      --primary: #2563eb;
      --primary-contrast: #ffffff;
      --danger: #ef4444;
      --success: #16a34a;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; color: var(--text);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg);
      display: grid; grid-template-rows: auto 1fr auto; overflow: hidden;
    }

    header, footer {
      padding: 12px 20px; background: var(--surface); border-bottom: 1px solid var(--border);
    }
    footer { border-top: 1px solid var(--border); border-bottom: none; font-size: 12px; color: var(--muted); }
    header h1 { margin: 0; font-size: 20px; }
    .sub { font-size: 13px; color: var(--muted); }

    .wrap { display: grid; grid-template-columns: 300px 1fr 300px; gap: 16px; padding: 16px; height: 100%; min-height: 0; }
    @media (max-width: 1100px){ .wrap { grid-template-columns: 1fr; overflow: auto; } body { overflow: auto; } .canvas-wrap { max-height: 60vh; } }

    .panel { background: var(--surface); border: 1px solid var(--border); border-radius: 12px; padding: 14px; box-shadow: 0 1px 2px rgba(0,0,0,.04); display: grid; gap: 12px; align-content: start; }
    .group { display: grid; gap: 8px; }
    .group h3 { margin: 2px 0 4px; font-size: 13px; color: var(--muted); text-transform: uppercase; letter-spacing: .2px; }
    .row { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 8px; }
    .note { font-size: 12px; color: var(--muted); }

    .btn { appearance: none; border: 1px solid var(--border); background: var(--surface); color: var(--text); border-radius: 8px; padding: 8px 12px; font-weight: 600; font-size: 13px; cursor: pointer; transition: background .15s ease, transform .06s ease; }
    .btn:hover { transform: translateY(-1px); background: #f1f5f9; }
    .btn.primary { background: var(--primary); color: var(--primary-contrast); border-color: var(--primary); }
    .btn.primary:hover { filter: brightness(0.95); }
    .btn.danger { background: #fee2e2; color: #991b1b; border-color: #fecaca; }
    .btn.ok { background: #dcfce7; color: #065f46; border-color: #bbf7d0; }

    input[type="number"], input[type="range"] { background: var(--surface); border: 1px solid var(--border); color: var(--text); border-radius: 8px; padding: 6px 8px; outline: none; }
    .toggle { display: inline-flex; align-items: center; gap: 8px; font-size: 13px; }

    .canvas-wrap { position: relative; background: var(--surface); border: 1px solid var(--border); border-radius: 12px; overflow: hidden; aspect-ratio: 1100 / 720; }
    canvas { display: block; width: 100%; height: auto; background: #ffffff; aspect-ratio: 1100 / 720; }

    .legend { display: grid; gap: 6px; font-size: 12px; color: var(--muted); }
    .kbd { padding: 2px 6px; border-radius: 6px; border: 1px solid var(--border); background: #f1f5f9; color: #0f172a; }

    .mono { font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    a { color: var(--primary); text-decoration: none; }
  </style>
</head>
<body>
  <header>
    <div style="display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;">
      <div>
        <h1>⚡ Electrostatics 2 — Equipotentials & Electron Flow</h1>
        <div class="sub">Hot→cool gradient for potential. Simulate electron flow along field lines.</div>
      </div>
      <div style="display:flex; gap:8px; align-items:center;">
        <button id="simulate" class="btn primary" title="Toggle electron flow and field lines">Simulate Flow</button>
        <button id="resetSim" class="btn" title="Stop and clear electrons">Reset</button>
      </div>
    </div>
  </header>

  <main class="wrap">
    <aside class="panel">
      <div class="group">
        <h3>Charges</h3>
        <div class="row"><button id="addPos" class="btn ok" title="Add +1 µC near center">+ Add +1 µC</button><div class="note">Positive charge</div></div>
        <div class="row"><button id="addNeg" class="btn danger" title="Add −1 µC near center">+ Add −1 µC</button><div class="note">Negative charge</div></div>
        <div class="row"><button id="clear" class="btn danger" title="Remove all charges">Clear All</button><div class="note">Reset scene</div></div>
      </div>

      <div class="group">
        <h3>Presets</h3>
        <div class="row"><button id="dipole" class="btn">Dipole</button><div class="note">+q and −q</div></div>
      </div>

      <div class="group">
        <h3>Display</h3>
        <label class="toggle"><input type="checkbox" id="showHeat" checked /> Show potential heatmap (hot→cool)</label>
        <div class="row"><label>Heatmap detail</label><input id="heatRes" type="range" min="120" max="480" step="20" value="260" /></div>
        <label class="toggle"><input type="checkbox" id="showVectors" /> Show field vectors E</label>
        <div class="row"><label>Display range (±V)</label><input id="displayRangeV2" type="number" min="2" step="2" value="40" style="width:90px;" /></div>
      </div>

      <div class="group">
        <h3>Cloud Sync</h3>
        <div class="note">Optionally save/load presets to the cloud (Firestore). Requires consent.</div>
        <label class="toggle"><input type="checkbox" id="cloudEnable" /> Enable cloud sync</label>
        <div class="row"><label>Preset name</label><input id="presetName" type="text" placeholder="e.g., Dipole-1" style="width:140px;" /></div>
        <div class="row"><button id="savePreset" class="btn" disabled>Save preset</button><div class="note">Saves charges + display</div></div>
        <div class="row"><button id="loadLatest" class="btn" disabled>Load latest</button><div class="note">Loads your latest preset</div></div>
        <div class="note" id="cloudStatus" style="color:#64748b;">Cloud: disabled</div>
      </div>

      <div class="group">
        <h3>Interaction</h3>
        <div class="legend">
          <div>Drag charges. Hold <span class="kbd">Shift</span> while dragging to duplicate.</div>
          <div>Electrons flow opposite to E (since q<0).</div>
        </div>
      </div>
    </aside>

    <section class="canvas-wrap">
      <canvas id="canvas" width="1100" height="720" aria-label="Electrostatics simulation"></canvas>
    </section>

    <aside class="panel">
      <div class="group">
        <h3>Probe (cursor)</h3>
        <div class="row"><div>E |N/C|</div><div class="mono" id="E_mag">—</div></div>
        <div class="row"><div>V (potential)</div><div class="mono" id="V">—</div></div>
      </div>
      <div class="group">
        <h3>About</h3>
        <div class="note">Heatmap shows V: hot (red) for higher V, cool (blue) for lower V. Field lines and electrons appear when you press <em>Simulate Flow</em>.</div>
        <div class="note">Style guided by <a href="https://learnhw.web.app/admin" target="_blank" rel="noopener">admin design</a>.</div>
      </div>
    </aside>
  </main>

  <footer>© 2025 • Electrostatics visualization — equipotentials and electron flow</footer>

  <!-- Cookie/Storage consent banner -->
  <div id="cookie-consent" style="position:fixed;left:0;right:0;bottom:0;padding:12px 16px;background:#111827;color:#ffffff;display:none;z-index:9999;border-top:1px solid rgba(255,255,255,.1)">
    This site uses cookies and local storage to remember preferences.
    <button id="cookie-accept" class="btn" style="margin-left:8px;background:#16a34a;color:#fff;border-color:#16a34a">Accept</button>
    <button id="cookie-decline" class="btn" style="margin-left:6px">Decline</button>
  </div>

  <script>
    // -------- Storage helpers --------
    const storage = {
      get(key, fallback = null) {
        try { const v = localStorage.getItem(key); return v === null ? fallback : JSON.parse(v); } catch { return fallback; }
      },
      set(key, value) { try { localStorage.setItem(key, JSON.stringify(value)); } catch {} },
      remove(key) { try { localStorage.removeItem(key); } catch {} }
    };

    // -------- Cookie helpers --------
    function setCookie(name, value, days = 365) {
      const expires = new Date(Date.now() + days*864e5).toUTCString();
      const secure = location.protocol === 'https:' ? '; Secure' : '';
      document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value) + '; Expires=' + expires + '; Path=/; SameSite=Lax' + secure;
    }
    function getCookie(name) {
      const row = document.cookie.split('; ').find(r => r.startsWith(encodeURIComponent(name) + '='));
      return row ? decodeURIComponent(row.split('=')[1]) : undefined;
    }
    function deleteCookie(name) {
      const secure = location.protocol === 'https:' ? '; Secure' : '';
      document.cookie = encodeURIComponent(name) + '=; Expires=Thu, 01 Jan 1970 00:00:00 GMT; Path=/; SameSite=Lax' + secure;
    }

    // Physics constants
    const k = 8.9875517923e9; // N m^2 / C^2
    const meterPerPixel = 0.01; // 1 px = 1 cm
    const soften = 0.01; // m — avoid singularities

    // Elements
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const addPosBtn = document.getElementById('addPos');
    const addNegBtn = document.getElementById('addNeg');
    const clearBtn = document.getElementById('clear');
    const dipoleBtn = document.getElementById('dipole');
    const simulateBtn = document.getElementById('simulate');
    const resetSimBtn = document.getElementById('resetSim');
    const showHeatEl = document.getElementById('showHeat');
    const heatResEl = document.getElementById('heatRes');
    const showVectorsEl = document.getElementById('showVectors');
    const displayRangeEl2 = document.getElementById('displayRangeV2');
    const E_magEl = document.getElementById('E_mag');
    const VEl = document.getElementById('V');
    const cloudEnableEl = document.getElementById('cloudEnable');
    const presetNameEl = document.getElementById('presetName');
    const savePresetBtn = document.getElementById('savePreset');
    const loadLatestBtn = document.getElementById('loadLatest');
    const cloudStatusEl = document.getElementById('cloudStatus');
    const consentBar = document.getElementById('cookie-consent');
    const consentAccept = document.getElementById('cookie-accept');
    const consentDecline = document.getElementById('cookie-decline');

    // State
    const charges = []; // {id,x,y,qMicroC,locked}
    let selectedId = null;
    let draggingId = null; let dragOffset = {x:0,y:0}; let dupOnDrag = false;
    let heatCache = null; let heatDirty = true;
    let simRunning = false;
    let electrons = []; // {x,y,life}

    // Helpers
    function toMeters(dxPx, dyPx){ return { dx: dxPx * meterPerPixel, dy: dyPx * meterPerPixel }; }
    function E_and_V_at(x, y){
      let Ex = 0, Ey = 0, V = 0;
      for (const c of charges){
        const dxPx = x - c.x, dyPx = y - c.y;
        const {dx, dy} = toMeters(dxPx, dyPx);
        const r2 = dx*dx + dy*dy + soften*soften; const r = Math.sqrt(r2);
        const qC = c.qMicroC * 1e-6;
        const coeff = k * qC / (r2 * r);
        Ex += coeff * dx; Ey += coeff * dy; V += k * qC / r;
      }
      return {Ex, Ey, V};
    }
    function fmt(x, unit){ if(!isFinite(x)) return '—'; const ax=Math.abs(x); let v=x, p=''; if(ax>=1e6){v=x/1e6;p='M';} else if(ax>=1e3){v=x/1e3;p='k';} else if(ax<1e-6){v=x*1e9;p='n';} else if(ax<1e-3){v=x*1e6;p='µ';} else if(ax<1){v=x*1e3;p='m';} return v.toFixed(3).replace(/\.0+$/,'').replace(/(\.\d*?)0+$/,'$1')+ ' ' + p + unit; }

    // Heatmap: purple (low) → blue → green → yellow → orange → red (high)
    function colorHotCool(t){ // t in [-1,1]
      const clamp=(v,min,max)=>Math.max(min,Math.min(max,v)); t=clamp(t,-1,1);
      const stops = [
        { t:-1.0, c:[128,0  ,128, 185] }, // purple
        { t:-0.6, c:[0  ,102,204, 185] }, // blue
        { t:-0.2, c:[0  ,153,0  , 185] }, // green
        { t: 0.2, c:[255,235,59 , 185] }, // yellow
        { t: 0.6, c:[255,152,0  , 185] }, // orange
        { t: 1.0, c:[211,47 ,47 , 185] }  // red
      ];
      for(let i=0;i<stops.length-1;i++){
        const a=stops[i], b=stops[i+1];
        if(t>=a.t && t<=b.t){
          const u=(t-a.t)/(b.t-a.t);
          const lerp=(x,y,p)=>Math.round(x+(y-x)*p);
          return [ lerp(a.c[0],b.c[0],u), lerp(a.c[1],b.c[1],u), lerp(a.c[2],b.c[2],u), lerp(a.c[3],b.c[3],u) ];
        }
      }
      return stops[t<0?0:stops.length-1].c;
    }
    function computeHeatmap(){
      const w = parseInt(heatResEl.value,10); const h = Math.round(w * canvas.height / canvas.width);
      const off = document.createElement('canvas'); off.width = w; off.height = h; const ictx = off.getContext('2d');
      const img = ictx.createImageData(w,h); const Vs = new Float32Array(w*h);
      let vmin=Infinity, vmax=-Infinity, i=0;
      for(let j=0;j<h;j++){
        for(let i2=0;i2<w;i2++){
          const x = (i2+0.5) * canvas.width / w; const y = (j+0.5) * canvas.height / h;
          const {V} = E_and_V_at(x,y); Vs[i]=V; if(V<vmin) vmin=V; if(V>vmax) vmax=V; i++;
        }
      }
      const a = Math.max(Math.abs(vmin), Math.abs(vmax)) || 1;
      const userRange = Math.max(2, Math.abs(parseFloat(displayRangeEl2.value)||40));
      const Vclip = Math.min(a, userRange);
      const totalBands = Math.max(1, Math.floor((2 * Vclip) / 2)); // 2V per band
      i=0; for(let j=0;j<h;j++){
        for(let i2=0;i2<w;i2++){
          const Vraw = Vs[i++];
          const Vc = Math.max(-Vclip, Math.min(Vraw, Vclip));
          const bandIndex = Math.floor((Vc + Vclip) / 2);
          const tBand = totalBands > 0 ? (bandIndex / totalBands) : 0.5;
          const t = tBand * 2 - 1;
          const [r,g,b,a8] = colorHotCool(t); const k = (j*w + i2) * 4;
          img.data[k]=r; img.data[k+1]=g; img.data[k+2]=b; img.data[k+3]=a8;
        }
      }
      ictx.putImageData(img,0,0); heatCache = off; heatDirty=false;
    }

    // Field vectors (optional)
    function drawVectors(){
      const step = 50; // fixed density for clarity
      ctx.save(); ctx.strokeStyle = 'rgba(15,23,42,.7)'; ctx.lineWidth = 1;
      for(let y=step/2; y<canvas.height; y+=step){
        for(let x=step/2; x<canvas.width; x+=step){
          const {Ex,Ey} = E_and_V_at(x,y); const m = Math.hypot(Ex,Ey); if(m<=0) continue;
          const nx=Ex/m, ny=Ey/m; const len = Math.min(26, 6 + 8*Math.log10(1+m*1e6));
          const x2 = x + nx*len; const y2 = y + ny*len;
          ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x2,y2); ctx.stroke();
          const tx=-ny, ty=nx; ctx.beginPath(); ctx.moveTo(x2,y2);
          ctx.lineTo(x2 - nx*6 + tx*3, y2 - ny*6 + ty*3);
          ctx.lineTo(x2 - nx*6 - tx*3, y2 - ny*6 - ty*3);
          ctx.closePath(); ctx.fillStyle='rgba(15,23,42,.7)'; ctx.fill();
        }
      }
      ctx.restore();
    }

    // Field lines (shown during simulation)
    function drawFieldLines(){
      const seedsPer = 10, stepLen=6, maxSteps=1200;
      ctx.save(); ctx.strokeStyle='rgba(15,23,42,.35)'; ctx.lineWidth=1;
      for(const c of charges){
        const r0=16; for(let k=0;k<seedsPer;k++){
          const ang = (k/seedsPer)*Math.PI*2; let x=c.x+Math.cos(ang)*r0; let y=c.y+Math.sin(ang)*r0;
          ctx.beginPath(); ctx.moveTo(x,y);
          for(let s=0;s<maxSteps;s++){
            const {Ex,Ey}=E_and_V_at(x,y); const m=Math.hypot(Ex,Ey); if(m<1e-7) break;
            const nx=Ex/m, ny=Ey/m; x+=nx*stepLen; y+=ny*stepLen; ctx.lineTo(x,y);
            if(x<0||y<0||x>canvas.width||y>canvas.height) break;
          }
          ctx.stroke();
        }
      }
      ctx.restore();
    }

    // Electron flow (particles move opposite to E)
    function seedElectrons(count=280){
      electrons.length=0; for(let i=0;i<count;i++){
        electrons.push({ x: Math.random()*canvas.width, y: Math.random()*canvas.height, life: Math.random()*800+400 });
      }
    }
    function stepElectrons(){
      const speedBase = 0.5; // slower base speed for clear observation
      for(const e of electrons){
        const {Ex,Ey} = E_and_V_at(e.x,e.y); const m = Math.hypot(Ex,Ey);
        if(m>0){ const nx=Ex/m, ny=Ey/m; // E direction
          // move opposite to E (electron, q<0), speed scales with field (log for stability) but capped
          const v = Math.min(1.2, speedBase * (1 + Math.log10(1+m*1e6)));
          e.x -= nx * v; e.y -= ny * v;
        }
        e.life -= 1; if(e.life<=0 || e.x<0||e.y<0||e.x>canvas.width||e.y>canvas.height){
          e.x = Math.random()*canvas.width; e.y = Math.random()*canvas.height; e.life = Math.random()*800+400;
        }
      }
    }
    function drawElectrons(){
      ctx.save();
      for(const e of electrons){
        // white circle with black border and 'e' inside
        ctx.beginPath();
        ctx.arc(e.x, e.y, 4, 0, Math.PI*2);
        ctx.fillStyle = '#ffffff';
        ctx.fill();
        ctx.lineWidth = 1.2;
        ctx.strokeStyle = '#000000';
        ctx.stroke();
        ctx.fillStyle = '#000000';
        ctx.font = 'bold 7px system-ui, -apple-system, Segoe UI';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText('e', e.x, e.y+0.3);
      }
      ctx.restore();
    }

    // Charges drawing & interaction
    function drawCharges(){
      for(const c of charges){
        const r=12; ctx.beginPath(); ctx.fillStyle = c.qMicroC>=0 ? '#ef4444' : '#3b82f6';
        ctx.strokeStyle='#0f172a'; ctx.lineWidth=1; ctx.arc(c.x,c.y,r,0,Math.PI*2); ctx.fill(); ctx.stroke();
        ctx.fillStyle='#ffffff'; ctx.font='bold 12px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(c.qMicroC>=0?'+':'−', c.x, c.y);
      }
    }
    function pickCharge(x,y){ for(let i=charges.length-1;i>=0;i--){ const c=charges[i]; if(Math.hypot(x-c.x,y-c.y)<=14) return c.id; } return null; }
    canvas.addEventListener('mousedown',(e)=>{
      const r=canvas.getBoundingClientRect(); const x=(e.clientX-r.left)*(canvas.width/r.width); const y=(e.clientY-r.top)*(canvas.height/r.height);
      const id=pickCharge(x,y); if(id){ const c=charges.find(c=>c.id===id); draggingId=id; selectedId=id; dupOnDrag=e.shiftKey; dragOffset.x=x-c.x; dragOffset.y=y-c.y; }
    });
    canvas.addEventListener('mousemove',(e)=>{
      const r=canvas.getBoundingClientRect(); const x=(e.clientX-r.left)*(canvas.width/r.width); const y=(e.clientY-r.top)*(canvas.height/r.height);
      const {Ex,Ey,V}=E_and_V_at(x,y); E_magEl.textContent=fmt(Math.hypot(Ex,Ey),'N/C'); VEl.textContent=fmt(V,'V');
      if(draggingId){ const i=charges.findIndex(c=>c.id===draggingId); if(i>=0){ if(dupOnDrag){ const c0=charges[i]; const dup=addCharge(c0.x,c0.y,c0.qMicroC); draggingId=dup.id; dupOnDrag=false; } const c=charges.find(c=>c.id===draggingId); c.x=x-dragOffset.x; c.y=y-dragOffset.y; heatDirty=true; } }
    });
    window.addEventListener('mouseup',()=>{ draggingId=null; });

    function addCharge(x,y,qMicroC){ const id=Math.random().toString(36).slice(2); charges.push({id,x,y,qMicroC,locked:false}); selectedId=id; heatDirty=true; return {id}; }
    function clearCharges(){ charges.length=0; selectedId=null; heatDirty=true; }
    function center(){ return {x: canvas.width/2, y: canvas.height/2}; }
    function presetDipole(){ clearCharges(); const c=center(); addCharge(c.x-90,c.y,+1.0); addCharge(c.x+90,c.y,-1.0); }

    // UI bindings
    addPosBtn.addEventListener('click',()=>{ const c=center(); addCharge(c.x+(Math.random()*60-30), c.y+(Math.random()*60-30), +1.0); });
    addNegBtn.addEventListener('click',()=>{ const c=center(); addCharge(c.x+(Math.random()*60-30), c.y+(Math.random()*60-30), -1.0); });
    clearBtn.addEventListener('click',()=>{ clearCharges(); heatDirty=true; });
    dipoleBtn.addEventListener('click',presetDipole);
    showHeatEl.addEventListener('change',()=>{ heatDirty=true; });
    heatResEl.addEventListener('input',()=>{ heatDirty=true; });
    showVectorsEl.addEventListener('change',()=>{ 
      storage.set('e2_showVectors', showVectorsEl.checked);
      // Also persist to Firestore collection if enabled/allowed
      cloudWriteVectorPref(showVectorsEl.checked).catch(()=>{});
    });
    displayRangeEl2.addEventListener('input',()=>{ storage.set('e2_displayRangeV', Number(displayRangeEl2.value)); heatDirty=true; });
    showHeatEl.addEventListener('change',()=>{ storage.set('e2_showHeat', showHeatEl.checked); heatDirty=true; });

    // Consent banner
    const consentKey = 'e2_cookie_consent';
    function adjustForBanner(on){
      const wrap = document.querySelector('.wrap');
      if (!wrap) return;
      if (on) {
        const h = consentBar?.offsetHeight || 0;
        wrap.style.paddingBottom = (h + 8) + 'px';
      } else {
        wrap.style.paddingBottom = '';
      }
    }
    function maybeShowConsent(){ if (!getCookie(consentKey)) { consentBar.style.display = 'block'; setTimeout(()=>adjustForBanner(true), 0); } }
    consentAccept?.addEventListener('click', ()=>{ setCookie(consentKey,'yes',365); consentBar.style.display='none'; adjustForBanner(false); });
    consentDecline?.addEventListener('click', ()=>{ setCookie(consentKey,'no',365); consentBar.style.display='none'; adjustForBanner(false); });
    simulateBtn.addEventListener('click',()=>{ simRunning=!simRunning; simulateBtn.textContent = simRunning? 'Stop' : 'Simulate Flow'; if(simRunning){ if(electrons.length===0) seedElectrons(); } });
    resetSimBtn.addEventListener('click',()=>{ simRunning=false; simulateBtn.textContent='Simulate Flow'; electrons.length=0; });

    // -------- Firestore (optional) --------
    let fb = { app:null, db:null, auth:null, uid:null };

    async function maybeInitFirebase(){
      try {
        const cfg = window.FIREBASE_CONFIG; // Provide via global on your hosting or insert snippet
        if (!cfg) { cloudStatusEl.textContent = 'Cloud: not configured'; return; }
        const { initializeApp } = await import('https://www.gstatic.com/firebasejs/10.13.1/firebase-app.js');
        const { getFirestore, collection, addDoc, getDocs, query, orderBy, limit } = await import('https://www.gstatic.com/firebasejs/10.13.1/firebase-firestore.js');
        const { getAuth, signInAnonymously, onAuthStateChanged } = await import('https://www.gstatic.com/firebasejs/10.13.1/firebase-auth.js');
        fb.app = initializeApp(cfg);
        fb.db = getFirestore(fb.app);
        fb.auth = getAuth(fb.app);
        await new Promise((res, rej)=>{
          onAuthStateChanged(fb.auth, async (user)=>{
            if (user) { fb.uid = user.uid; res(); }
            else { try { await signInAnonymously(fb.auth); } catch(e){ rej(e); } }
          });
        });
        savePresetBtn.disabled = false; loadLatestBtn.disabled = false;
        cloudStatusEl.textContent = 'Cloud: ready';
        // Attach handlers
        savePresetBtn.addEventListener('click', async ()=>{
          if (!cloudGuard()) return;
          try {
            const payload = currentPresetPayload();
            const name = (presetNameEl.value || 'Preset').slice(0, 60);
            payload.name = name; payload.uid = fb.uid; payload.createdAt = Date.now();
            const col = collection(fb.db, 'users', fb.uid, 'electro_presets');
            await addDoc(col, payload);
            cloudStatusEl.textContent = 'Cloud: saved ✔';
          } catch (e) { cloudStatusEl.textContent = 'Cloud: save failed'; }
        });
        loadLatestBtn.addEventListener('click', async ()=>{
          if (!cloudGuard()) return;
          try {
            const { collection, getDocs, query, orderBy, limit } = await import('https://www.gstatic.com/firebasejs/10.13.1/firebase-firestore.js');
            const col = collection(fb.db, 'users', fb.uid, 'electro_presets');
            const qs = await getDocs(query(col, orderBy('createdAt', 'desc'), limit(1)));
            if (qs.empty) { cloudStatusEl.textContent = 'Cloud: no presets'; return; }
            const data = qs.docs[0].data();
            applyPresetPayload(data);
            cloudStatusEl.textContent = 'Cloud: loaded ✔';
          } catch (e) { cloudStatusEl.textContent = 'Cloud: load failed'; }
        });
      } catch (e) {
        cloudStatusEl.textContent = 'Cloud: unavailable';
      }
    }

    function currentPresetPayload(){
      return {
        charges: charges.map(c=>({ x: Math.round(c.x), y: Math.round(c.y), qMicroC: c.qMicroC })),
        display: {
          showHeat: !!showHeatEl.checked,
          showVectors: !!showVectorsEl.checked,
          heatRes: parseInt(heatResEl.value,10),
          rangeV: parseFloat(displayRangeEl2.value)
        }
      };
    }
    function applyPresetPayload(p){
      if (p?.charges) {
        clearCharges();
        for (const c of p.charges) addCharge(c.x, c.y, c.qMicroC);
      }
      if (p?.display) {
        showHeatEl.checked = !!p.display.showHeat;
        showVectorsEl.checked = !!p.display.showVectors;
        heatResEl.value = p.display.heatRes ?? heatResEl.value;
        displayRangeEl2.value = p.display.rangeV ?? displayRangeEl2.value;
        storage.set('e2_showHeat', showHeatEl.checked);
        storage.set('e2_showVectors', showVectorsEl.checked);
        storage.set('e2_displayRangeV', Number(displayRangeEl2.value));
        heatDirty = true;
      }
    }

    function cloudGuard(){
      const consent = getCookie?.('e2_cookie_consent');
      if (consent !== 'yes') { cloudStatusEl.textContent = 'Cloud: requires cookie consent'; return false; }
      if (!cloudEnableEl.checked) { cloudStatusEl.textContent = 'Cloud: toggle enable first'; return false; }
      if (!fb.db || !fb.uid) { cloudStatusEl.textContent = 'Cloud: not ready'; return false; }
      return true;
    }

    cloudEnableEl?.addEventListener('change', ()=>{
      const on = !!cloudEnableEl.checked;
      storage.set('e2_cloud_enabled', on);
      savePresetBtn.disabled = !on || !fb.db; loadLatestBtn.disabled = !on || !fb.db;
      cloudStatusEl.textContent = on ? 'Cloud: enabled' : 'Cloud: disabled';
      if (on) { cloudLoadLatestVectorPref().catch(()=>{}); }
    });

    // Write vector preference to collection `users/{uid}/vector_prefs`
    async function cloudWriteVectorPref(show){
      if (!cloudGuard()) return;
      try {
        const { collection, addDoc } = await import('https://www.gstatic.com/firebasejs/10.13.1/firebase-firestore.js');
        const col = collection(fb.db, 'users', fb.uid, 'vector_prefs');
        await addDoc(col, { showVectors: !!show, createdAt: Date.now() });
        cloudStatusEl.textContent = 'Cloud: vector pref saved ✔';
      } catch (_) { /* ignore UI noise */ }
    }

    // Load latest vector preference
    async function cloudLoadLatestVectorPref(){
      if (!cloudGuard()) return;
      try {
        const { collection, getDocs, query, orderBy, limit } = await import('https://www.gstatic.com/firebasejs/10.13.1/firebase-firestore.js');
        const col = collection(fb.db, 'users', fb.uid, 'vector_prefs');
        const qs = await getDocs(query(col, orderBy('createdAt', 'desc'), limit(1)));
        if (qs.empty) return;
        const data = qs.docs[0].data();
        if (typeof data.showVectors === 'boolean') {
          showVectorsEl.checked = data.showVectors;
          storage.set('e2_showVectors', data.showVectors);
        }
      } catch (_) { /* ignore */ }
    }

    // Render
    function render(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if(showHeatEl.checked){ if(heatDirty) computeHeatmap(); ctx.drawImage(heatCache,0,0,canvas.width,canvas.height); }
      if(simRunning){ drawFieldLines(); stepElectrons(); drawElectrons(); }
      if(showVectorsEl.checked){ drawVectors(); }
      drawCharges();
      requestAnimationFrame(render);
    }

    // Restore preferences
    (function restorePrefs(){
      const savedRange = storage.get('e2_displayRangeV', 40);
      const savedShowHeat = storage.get('e2_showHeat', true);
      const savedShowVectors = storage.get('e2_showVectors', false);
      if (displayRangeEl2) displayRangeEl2.value = savedRange;
      if (showHeatEl) showHeatEl.checked = !!savedShowHeat;
      if (showVectorsEl) showVectorsEl.checked = !!savedShowVectors;
      heatDirty = true;
    })();

    // Init
    (function restoreCloudToggle(){
      const on = !!storage.get('e2_cloud_enabled', false);
      if (cloudEnableEl) cloudEnableEl.checked = on;
      savePresetBtn.disabled = !on; loadLatestBtn.disabled = !on;
      cloudStatusEl.textContent = on ? 'Cloud: enabled' : 'Cloud: disabled';
    })();
    presetDipole();
    render();
    maybeShowConsent();
    maybeInitFirebase();
  </script>
</body>
</html>

